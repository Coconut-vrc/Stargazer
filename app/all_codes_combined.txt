################################################################################
 DIRECTORY STRUCTURE
################################################################################

. (ROOT: app)
├── all_codes_combined.txt
├── api
│   └── sheets
│       └── route.ts
├── collector.py
├── common
│   └── types
│       ├── discord-colors.ts
│       ├── DISCORD_DESIGN_GUIDE.md
│       ├── globals-discord.css
│       └── MatchingPage-discord.tsx
├── components
│   ├── layout
│   └── ui
├── favicon.ico
├── features
│   └── matching
│       ├── components
│       ├── logics
│       │   └── matching_service.ts
│       └── services
├── globals.css
├── infrastructures
│   └── googleSheets
│       └── sheet_service.ts
├── layout.tsx
├── memo
├── mock
│   └── test.html
├── page.tsx
├── pages
│   ├── AppContainer.css
│   ├── AppContainer.tsx
│   ├── CastManagement
│   ├── CastManagementPage.tsx
│   ├── DBView
│   ├── DBViewPage.tsx
│   ├── Import
│   ├── ImportPage.tsx
│   ├── Lottery
│   ├── LotteryPage.tsx
│   ├── Matching
│   └── MatchingPage.tsx
└── stores
    └── AppContext.tsx

################################################################################


================================================================================
 FILE: api\sheets\route.ts
================================================================================

// F:\DEVELOPFOLDER\dev-core\app\api\sheets\route.ts

import { google } from 'googleapis';
import { NextResponse } from 'next/server';
import path from 'path';

export async function POST(request: Request) {
  try {
    const { spreadsheetId, range } = await request.json();

    // ルートディレクトリ（dev-core）にある credentials.json を読み込む
    const keyFile = path.join(process.cwd(), 'credentials.json');

    const auth = new google.auth.GoogleAuth({
      keyFile: keyFile,
      scopes: ['https://www.googleapis.com/auth/spreadsheets.readonly'],
    });

    const sheets = google.sheets({ version: 'v4', auth });
    
    const response = await sheets.spreadsheets.values.get({
      spreadsheetId,
      range,
    });

    return NextResponse.json({ values: response.data.values });
  } catch (error: any) {
    console.error('Google Sheets API Error:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

================================================================================
 FILE: collector.py
================================================================================

import pathlib

def generate_tree(path, prefix=""):
    """ディレクトリ構造をテキストのツリー形式で生成する"""
    tree_str = ""
    # node_modules や .git などは除外
    exclude = {".git", "node_modules", "__pycache__", ".next", ".vscode", "dist"}
    
    try:
        items = sorted([p for p in path.iterdir() if p.name not in exclude])
    except PermissionError:
        return ""

    for i, item in enumerate(items):
        connector = "└── " if i == len(items) - 1 else "├── "
        tree_str += f"{prefix}{connector}{item.name}\n"
        if item.is_dir():
            extension = "    " if i == len(items) - 1 else "│   "
            tree_str += generate_tree(item, prefix + extension)
    return tree_str

def merge_code_files(target_dir: str, output_file: str):
    base_path = pathlib.Path(target_dir)
    output_path = pathlib.Path(output_file)
    
    # CSSを追加
    extensions = {".py", ".ts", ".tsx", ".css"}
    
    # 対象ファイルを取得
    code_files = sorted([
        p for p in base_path.rglob("*") 
        if p.suffix in extensions and p.is_file()
    ])
    
    with output_path.open("w", encoding="utf-8") as f_out:
        # --- 冒頭にディレクトリ構造を書き込む ---
        f_out.write(f"{'#'*80}\n")
        f_out.write(f" DIRECTORY STRUCTURE\n")
        f_out.write(f"{'#'*80}\n\n")
        f_out.write(f". (ROOT: {base_path.resolve().name})\n")
        f_out.write(generate_tree(base_path))
        f_out.write(f"\n{'#'*80}\n\n")

        # --- 各ファイルの内容を書き込む ---
        for code_file in code_files:
            # 自分自身や特定のディレクトリを除外
            if code_file.resolve() == output_path.resolve():
                continue
            if any(part in code_file.parts for part in ["node_modules", ".next", ".git", "__pycache__"]):
                continue
                
            relative_path = code_file.relative_to(base_path)
            
            f_out.write(f"\n{'='*80}\n")
            f_out.write(f" FILE: {relative_path}\n")
            f_out.write(f"{'='*80}\n\n")
            
            try:
                content = code_file.read_text(encoding="utf-8")
                f_out.write(content)
                f_out.write("\n")
                print(f"Combined: {relative_path}")
            except Exception as e:
                f_out.write(f"Error reading file: {e}\n")
                print(f"Failed to read: {relative_path}")

if __name__ == "__main__":
    # カレントディレクトリを対象に all_codes_combined.txt を生成
    merge_code_files(".", "all_codes_combined.txt")

================================================================================
 FILE: common\types\discord-colors.ts
================================================================================

// app/common/types/discord-colors.ts
// app/mock/test.html から抽出したカラーリング

export const DiscordColors = {
  // test.html :root の背景色
  purpleDeep: '#1A0A1A',   // 左上の赤紫
  violetMid: '#0D0B1E',    // ベースの暗紫
  navyDark: '#05121B',     // 右下の紺

  // 背景（グラデーション上で使う半透明）
  bgSidebar: 'rgba(0, 0, 0, 0.2)',
  bgMain: 'transparent',
  bgDark: 'rgba(0, 0, 0, 0.25)',
  bgSecondary: 'rgba(255, 255, 255, 0.05)',
  itemHover: 'rgba(255, 255, 255, 0.06)',
  itemActive: 'rgba(255, 255, 255, 0.08)',
  bgAlt: 'rgba(0, 0, 0, 0.15)',

  // テキスト・ライン（test.html と同一）
  textNormal: '#dbdee1',
  textMuted: 'rgba(255, 255, 255, 0.4)',
  textActive: '#ffffff',
  textHeader: '#f2f3f5',
  textLink: '#00a8fc',

  border: 'rgba(255, 255, 255, 0.1)',
  lineColor: 'rgba(255, 255, 255, 0.1)',

  // アクセント（ボタン等）
  accentBlue: '#5865f2',
  accentGreen: '#23a559',
  accentYellow: '#f0b232',
  accentRed: '#ed4245',
  buttonSuccess: '#23a559',
  bgHover: 'rgba(255, 255, 255, 0.08)',

  // 後方互換用エイリアス
  bgServerList: '#1A0A1A',
} as const;


================================================================================
 FILE: common\types\globals-discord.css
================================================================================

/* ========================================
   Discord風グローバルスタイル
   ======================================== */

:root {
  /* app/mock/test.html から抽出したカラーリング */
  --color-purple-deep: #1A0A1A;
  --color-violet-mid: #0D0B1E;
  --color-navy-dark: #05121B;
  --text-main: #dbdee1;
  --text-muted: rgba(255, 255, 255, 0.4);
  --line-color: rgba(255, 255, 255, 0.1);

  /* 上記に合わせた Discord 系変数（全体で利用） */
  --discord-bg-dark: rgba(0, 0, 0, 0.25);
  --discord-bg-main: transparent;
  --discord-bg-secondary: rgba(255, 255, 255, 0.05);
  --discord-bg-hover: rgba(255, 255, 255, 0.08);
  --discord-bg-selected: rgba(255, 255, 255, 0.08);
  --discord-bg-alt: rgba(0, 0, 0, 0.15);

  --discord-text-normal: #dbdee1;
  --discord-text-muted: rgba(255, 255, 255, 0.4);
  --discord-text-link: #00a8fc;
  --discord-text-success: #23a559;
  --discord-text-warning: #f0b232;
  --discord-text-danger: #ed4245;

  --discord-accent-blue: #5865f2;
  --discord-accent-green: #23a559;
  --discord-accent-yellow: #f0b232;
  --discord-accent-red: #ed4245;

  --discord-border: rgba(255, 255, 255, 0.1);
  --discord-divider: rgba(255, 255, 255, 0.1);

  --discord-button-primary: #5865f2;
  --discord-button-primary-hover: #4752c4;
  --discord-button-secondary: rgba(255, 255, 255, 0.1);
  --discord-button-secondary-hover: rgba(255, 255, 255, 0.15);
  --discord-button-success: #23a559;
  --discord-button-success-hover: #2d7d46;
  --discord-button-danger: #ed4245;
}

/* ========================================
   基本リセット
   ======================================== */

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html,
body {
  max-width: 100vw;
  overflow-x: hidden;
  font-family: "Whitney", "Helvetica Neue", Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

body {
  background-color: var(--discord-bg-main);
  color: var(--discord-text-normal);
}

/* ========================================
   リンク
   ======================================== */

a {
  color: var(--discord-text-link);
  text-decoration: none;
  transition: color 0.17s ease;
}

a:hover {
  text-decoration: underline;
}

/* ========================================
   ボタン
   ======================================== */

button {
  font-family: inherit;
  cursor: pointer;
  border: none;
  border-radius: 4px;
  font-weight: 500;
  transition: background-color 0.17s ease, transform 0.17s ease;
}

button:hover {
  transform: translateY(-1px);
}

button:active {
  transform: translateY(0);
}

/* プライマリボタン */
.btn-primary {
  background-color: var(--discord-button-primary);
  color: #fff;
  padding: 10px 20px;
  font-size: 14px;
}

.btn-primary:hover {
  background-color: var(--discord-button-primary-hover);
}

/* 成功ボタン */
.btn-success {
  background-color: var(--discord-button-success);
  color: #fff;
  padding: 10px 20px;
  font-size: 14px;
}

.btn-success:hover {
  background-color: var(--discord-button-success-hover);
}

/* セカンダリボタン */
.btn-secondary {
  background-color: var(--discord-button-secondary);
  color: var(--discord-text-normal);
  padding: 10px 20px;
  font-size: 14px;
}

.btn-secondary:hover {
  background-color: var(--discord-button-secondary-hover);
}

/* 危険ボタン */
.btn-danger {
  background-color: var(--discord-button-danger);
  color: #fff;
  padding: 10px 20px;
  font-size: 14px;
}

.btn-danger:hover {
  background-color: #c23636;
}

/* ========================================
   入力フィールド
   ======================================== */

input,
textarea,
select {
  background-color: var(--discord-bg-secondary);
  color: var(--discord-text-normal);
  border: 1px solid var(--discord-border);
  border-radius: 4px;
  padding: 10px 12px;
  font-size: 14px;
  font-family: inherit;
  transition: border-color 0.17s ease;
}

input:focus,
textarea:focus,
select:focus {
  outline: none;
  border-color: var(--discord-accent-blue);
}

input::placeholder,
textarea::placeholder {
  color: var(--discord-text-muted);
}

/* ========================================
   テーブル
   ======================================== */

table {
  width: 100%;
  border-collapse: collapse;
  background-color: var(--discord-bg-dark);
  border-radius: 8px;
  overflow: hidden;
}

thead th {
  background-color: var(--discord-bg-secondary);
  color: var(--discord-text-muted);
  padding: 12px 16px;
  text-align: left;
  font-size: 12px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  border-bottom: 1px solid var(--discord-border);
}

tbody td {
  padding: 12px 16px;
  font-size: 14px;
  color: var(--discord-text-normal);
  border-bottom: 1px solid var(--discord-border);
}

tbody tr:hover {
  background-color: var(--discord-bg-hover);
}

tbody tr:nth-child(even) {
  background-color: var(--discord-bg-alt);
}

/* ========================================
   カード
   ======================================== */

.card {
  background-color: var(--discord-bg-dark);
  border-radius: 8px;
  padding: 20px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
}

.card-header {
  margin-bottom: 16px;
  padding-bottom: 16px;
  border-bottom: 1px solid var(--discord-border);
}

.card-title {
  font-size: 20px;
  font-weight: 600;
  color: var(--discord-text-normal);
  margin: 0;
}

.card-subtitle {
  font-size: 14px;
  color: var(--discord-text-muted);
  margin-top: 4px;
}

/* ========================================
   スクロールバー（Webkit）
   ======================================== */

::-webkit-scrollbar {
  width: 16px;
}

::-webkit-scrollbar-track {
  background-color: var(--discord-bg-main);
}

::-webkit-scrollbar-thumb {
  background-color: var(--discord-bg-secondary);
  border-radius: 8px;
  border: 4px solid var(--discord-bg-main);
}

::-webkit-scrollbar-thumb:hover {
  background-color: var(--discord-bg-hover);
}

/* ========================================
   ユーティリティクラス
   ======================================== */

.text-muted {
  color: var(--discord-text-muted);
}

.text-success {
  color: var(--discord-text-success);
}

.text-warning {
  color: var(--discord-text-warning);
}

.text-danger {
  color: var(--discord-text-danger);
}

.text-link {
  color: var(--discord-text-link);
}

.bg-dark {
  background-color: var(--discord-bg-dark);
}

.bg-main {
  background-color: var(--discord-bg-main);
}

.bg-secondary {
  background-color: var(--discord-bg-secondary);
}

.border-bottom {
  border-bottom: 1px solid var(--discord-border);
}

.rounded {
  border-radius: 8px;
}

.rounded-sm {
  border-radius: 4px;
}

/* ========================================
   アニメーション
   ======================================== */

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.fade-in {
  animation: fadeIn 0.3s ease;
}

/* ========================================
   レスポンシブ
   ======================================== */

@media (max-width: 768px) {
  body {
    font-size: 14px;
  }

  .card {
    padding: 16px;
  }

  button {
    padding: 8px 16px;
    font-size: 13px;
  }
}


================================================================================
 FILE: common\types\MatchingPage-discord.tsx
================================================================================

import React, { useState } from 'react';
import { useAppContext } from '../stores/AppContext';
import { MatchingService } from '../features/matching/logics/matching_service';
import { DiscordColors } from './discord-colors'; // ← 追加

interface MatchingResult {
  pair_no: string;
  user_a: { name: string };
  user_b: { name: string };
  t1: string;
  t1_info: string;
  t2: string;
  t2_info: string;
  t3: string;
  t3_info: string;
}

export const MatchingPage: React.FC = () => {
  const { currentWinners, repository } = useAppContext();
  const [results, setResults] = useState<MatchingResult[]>([]);
  const [showResults, setShowResults] = useState(false);

  // ==================== スタイル定義（Discord風） ====================
  
  const containerStyle: React.CSSProperties = {
    width: '100%',
    minHeight: '100vh',
    backgroundColor: DiscordColors.bgMain, // ← Discord背景色
    color: DiscordColors.textNormal,       // ← Discord通常テキスト
    padding: '40px',
    boxSizing: 'border-box',
    fontFamily: '"Whitney", "Helvetica Neue", Helvetica, Arial, sans-serif',
    position: 'relative'
  };

  const headerStyle: React.CSSProperties = {
    marginBottom: '30px',
    paddingBottom: '20px',
    borderBottom: `2px solid ${DiscordColors.border}` // ← Discordボーダー
  };

  const tableWrapperStyle: React.CSSProperties = {
    overflowX: 'auto',
    borderRadius: '8px',
    backgroundColor: DiscordColors.bgDark, // ← Discord暗い背景
    padding: '20px',
    boxShadow: '0 2px 10px 0 rgba(0,0,0,0.2)'
  };

  const tableStyle: React.CSSProperties = {
    width: '100%',
    borderCollapse: 'collapse',
    backgroundColor: DiscordColors.bgDark, // ← Discord暗い背景
    borderRadius: '8px',
    overflow: 'hidden'
  };

  const headerCellStyle: React.CSSProperties = {
    backgroundColor: DiscordColors.bgSecondary, // ← Discord中間色
    color: DiscordColors.textMuted,             // ← Discord薄いテキスト
    padding: '16px',
    textAlign: 'left',
    fontSize: '12px',
    fontWeight: 600,
    textTransform: 'uppercase',
    letterSpacing: '0.5px',
    borderBottom: `1px solid ${DiscordColors.border}`
  };

  const cellStyle: React.CSSProperties = {
    padding: '14px 16px',
    fontSize: '14px',
    color: DiscordColors.textNormal, // ← Discord通常テキスト
    borderBottom: `1px solid ${DiscordColors.border}`
  };

  const floatingFooterStyle: React.CSSProperties = {
    position: 'fixed',
    bottom: 0,
    left: 0,
    width: '100%',
    height: '100px',
    display: 'flex',
    justifyContent: 'center',
    alignItems: 'center',
    background: `linear-gradient(to top, ${DiscordColors.bgMain} 50%, transparent)`,
    pointerEvents: 'none'
  };

  const primaryButtonStyle: React.CSSProperties = {
    backgroundColor: DiscordColors.buttonSuccess,      // ← Discord緑ボタン
    color: '#FFF',
    border: 'none',
    padding: '14px 80px',
    borderRadius: '4px', // Discordは角丸が少し小さい
    fontSize: '16px',
    fontWeight: 500,
    cursor: 'pointer',
    boxShadow: '0 8px 15px rgba(59, 165, 93, 0.3)',
    pointerEvents: 'auto',
    transition: 'background-color 0.17s ease, transform 0.17s ease',
  };

  const secondaryButtonStyle: React.CSSProperties = {
    backgroundColor: DiscordColors.buttonSecondary,      // ← Discordセカンダリボタン
    color: DiscordColors.textNormal,
    border: 'none',
    padding: '10px 30px',
    borderRadius: '4px',
    fontSize: '14px',
    fontWeight: 500,
    cursor: 'pointer',
    pointerEvents: 'auto',
    marginTop: '20px',
    transition: 'background-color 0.17s ease'
  };

  const getRowStyle = (index: number): React.CSSProperties => ({
    backgroundColor: index % 2 === 0 ? 'transparent' : DiscordColors.bgAlt, // ← Discord交互の行色
    transition: 'background-color 0.1s ease'
  });

  // ==================== ロジック ====================

  const startMatching = () => {
    if (currentWinners.length === 0) {
      alert('当選者が選択されていません。抽選ページからやり直してください。');
      return;
    }
    const service = new MatchingService(currentWinners, repository);
    const matchingResults = service.runMatching();
    setResults(matchingResults as MatchingResult[]);
    setShowResults(true);
  };

  // ==================== マッチング完了後の表示 ====================
  if (showResults) {
    return (
      <div style={containerStyle}>
        <div style={headerStyle}>
          <h1 style={{ 
            margin: 0, 
            fontSize: '24px', 
            fontWeight: 600, 
            color: DiscordColors.textSuccess // ← Discord成功色
          }}>
            マッチング完了
          </h1>
          <p style={{ 
            margin: '4px 0 0 0', 
            fontSize: '14px', 
            color: DiscordColors.textMuted // ← Discord薄いテキスト
          }}>
            生成された3ターンのローテーション案です
          </p>
        </div>

        <div style={tableWrapperStyle}>
          <table style={tableStyle}>
            <thead>
              <tr>
                <th style={{...headerCellStyle, borderRadius: '8px 0 0 0'}}>ペア</th>
                <th style={headerCellStyle}>ユーザーA</th>
                <th style={headerCellStyle}>ユーザーB</th>
                <th style={headerCellStyle}>T1 (担当)</th>
                <th style={headerCellStyle}>T2 (担当)</th>
                <th style={{...headerCellStyle, borderRadius: '0 8px 0 0'}}>T3 (担当)</th>
              </tr>
            </thead>
            <tbody>
              {results.map((result, index) => (
                <tr key={index} style={getRowStyle(index)}>
                  <td style={{ ...cellStyle, color: DiscordColors.accentBlue, fontWeight: 600 }}>
                    {result.pair_no}
                  </td>
                  <td style={{ ...cellStyle, color: DiscordColors.textNormal }}>
                    {result.user_a.name}
                  </td>
                  <td style={{ ...cellStyle, color: DiscordColors.textNormal }}>
                    {result.user_b.name}
                  </td>
                  <td style={cellStyle}>
                    <div style={{ color: DiscordColors.accentYellow, fontWeight: 600 }}>
                      {result.t1}
                    </div>
                    <div style={{ color: DiscordColors.textMuted, fontSize: '12px' }}>
                      {result.t1_info}
                    </div>
                  </td>
                  <td style={cellStyle}>
                    <div style={{ color: DiscordColors.accentYellow, fontWeight: 600 }}>
                      {result.t2}
                    </div>
                    <div style={{ color: DiscordColors.textMuted, fontSize: '12px' }}>
                      {result.t2_info}
                    </div>
                  </td>
                  <td style={cellStyle}>
                    <div style={{ color: DiscordColors.accentYellow, fontWeight: 600 }}>
                      {result.t3}
                    </div>
                    <div style={{ color: DiscordColors.textMuted, fontSize: '12px' }}>
                      {result.t3_info}
                    </div>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
          <button 
            style={secondaryButtonStyle} 
            onClick={() => setShowResults(false)}
            onMouseEnter={(e) => (e.currentTarget.style.backgroundColor = DiscordColors.buttonSecondaryHover)}
            onMouseLeave={(e) => (e.currentTarget.style.backgroundColor = DiscordColors.buttonSecondary)}
          >
            ← 設定に戻る
          </button>
        </div>
      </div>
    );
  }

  // ==================== マッチング前の表示（確認画面） ====================
  const tableData = Array.from({ length: 15 }, (_, i) => {
    const winner = currentWinners && currentWinners[i];
    return {
      id: i + 1,
      user: winner ? winner.name : '--- (空席)',
      x_id: winner ? `@${winner.x_id}` : '',
      casts: winner ? winner.casts.join(', ') : 'なし'
    };
  });

  return (
    <div style={containerStyle}>
      <div style={headerStyle}>
        <h1 style={{ 
          margin: 0, 
          fontSize: '24px', 
          fontWeight: 600, 
          color: DiscordColors.textNormal 
        }}>
          マッチング構成確認
        </h1>
        <p style={{ 
          margin: '4px 0 0 0', 
          fontSize: '14px', 
          color: DiscordColors.textMuted 
        }}>
          当選者リストに基づきペアとローテーションを自動生成します
        </p>
      </div>

      <div style={tableWrapperStyle}>
        <table style={tableStyle}>
          <thead>
            <tr>
              <th style={{...headerCellStyle, borderRadius: '8px 0 0 0', width: '80px'}}>卓</th>
              <th style={headerCellStyle}>ユーザー名</th>
              <th style={headerCellStyle}>ID</th>
              <th style={{...headerCellStyle, borderRadius: '0 8px 0 0'}}>希望キャスト</th>
            </tr>
          </thead>
          <tbody>
            {tableData.map((table, index) => (
              <tr key={table.id} style={getRowStyle(index)}>
                <td style={{ ...cellStyle, color: DiscordColors.accentBlue, fontWeight: 600 }}>
                  卓 {table.id}
                </td>
                <td style={{ ...cellStyle, color: DiscordColors.textNormal }}>
                  {table.user}
                </td>
                <td style={{ ...cellStyle, color: DiscordColors.textMuted }}>
                  {table.x_id}
                </td>
                <td style={{ ...cellStyle, color: DiscordColors.textNormal, fontSize: '13px' }}>
                  {table.casts}
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>

      <div style={floatingFooterStyle}>
        <button 
          style={primaryButtonStyle}
          onMouseEnter={(e) => {
            e.currentTarget.style.backgroundColor = DiscordColors.buttonSuccessHover;
            e.currentTarget.style.transform = 'translateY(-2px)';
          }}
          onMouseLeave={(e) => {
            e.currentTarget.style.backgroundColor = DiscordColors.buttonSuccess;
            e.currentTarget.style.transform = 'translateY(0)';
          }}
          onClick={startMatching}
        >
          マッチング開始
        </button>
      </div>
    </div>
  );
};


================================================================================
 FILE: features\matching\logics\matching_service.ts
================================================================================

import { UserBean, CastBean, Repository } from '../../../stores/AppContext';

interface MatchingResult {
  pair_no: string;
  user_a: UserBean;
  user_b: UserBean;
  t1: string;
  t1_info: string;
  t2: string;
  t2_info: string;
  t3: string;
  t3_info: string;
}

export class MatchingService {
  private winners: UserBean[];
  private repository: Repository;

  constructor(winners: UserBean[], repository: Repository) {
    this.winners = winners;
    this.repository = repository;
  }

  runMatching(): MatchingResult[] {
    if (!this.winners.length) return [];

    const activeCasts = this.repository.getAllCasts()
      .filter(c => c.is_present)
      .map(c => c.name);

    if (!activeCasts.length) {
      console.error('[ERROR] 出席中のキャストがいません。');
      return [];
    }

    const pool = [...this.winners].sort(() => Math.random() - 0.5);
    const pairs: [UserBean, UserBean | null][] = [];

    for (let i = 0; i < pool.length; i += 2) {
      const u_a = pool[i];
      const u_b = i + 1 < pool.length ? pool[i + 1] : null;
      pairs.push([u_a, u_b]);
    }

    return this.generateSchedule(pairs, activeCasts);
  }

  private generateSchedule(pairs: [UserBean, UserBean | null][], activeCasts: string[]): MatchingResult[] {
    const results: MatchingResult[] = [];
    const usedByTurn: Set<string>[] = [new Set(), new Set(), new Set()];

    pairs.forEach(([u_a, u_b], index) => {
      const slots: (string | null)[] = [null, null, null];
      const assignedThisPair = new Set<string>();
      const turnOrder = [0, 1, 2].sort(() => Math.random() - 0.5);

      const getAvailableHopes = (hopes: string[], tIdx: number): string[] => {
        if (!hopes.length) return [];
        return hopes.filter(c => 
          activeCasts.includes(c) && 
          !usedByTurn[tIdx].has(c) && 
          !assignedThisPair.has(c)
        );
      };

      const hopesA = u_a.casts.filter(c => c && c.trim()).map(c => c.trim());
      
      for (const tIdx of turnOrder) {
        const available = getAvailableHopes(hopesA, tIdx);
        if (available.length) {
          const pick = available[Math.floor(Math.random() * available.length)];
          slots[tIdx] = pick;
          usedByTurn[tIdx].add(pick);
          assignedThisPair.add(pick);
          break;
        }
      }

      if (u_b) {
        const hopesB = u_b.casts.filter(c => c && c.trim()).map(c => c.trim());
        const remainingTurns = turnOrder.filter(t => slots[t] === null);
        
        for (const tIdx of remainingTurns) {
          const available = getAvailableHopes(hopesB, tIdx);
          if (available.length) {
            const pick = available[Math.floor(Math.random() * available.length)];
            slots[tIdx] = pick;
            usedByTurn[tIdx].add(pick);
            assignedThisPair.add(pick);
            break;
          }
        }
      }

      for (let tIdx = 0; tIdx < 3; tIdx++) {
        if (slots[tIdx] === null) {
          const freeCasts = activeCasts.filter(c => 
            !assignedThisPair.has(c) && !usedByTurn[tIdx].has(c)
          );
          
          if (freeCasts.length) {
            const pick = freeCasts[Math.floor(Math.random() * freeCasts.length)];
            slots[tIdx] = pick;
            usedByTurn[tIdx].add(pick);
            assignedThisPair.add(pick);
          } else {
            slots[tIdx] = '（空きなし）';
          }
        }
      }

      const emptyUser: UserBean = {
        timestamp: '', name: '---', x_id: '', first_flag: '', 
        casts: [], note: '', is_pair_ticket: false, raw_extra: []
      };

      const result: MatchingResult = {
        pair_no: `ペア${index + 1}`,
        user_a: u_a,
        user_b: u_b || emptyUser,
        t1: slots[0]!,
        t2: slots[1]!,
        t3: slots[2]!,
        t1_info: '',
        t2_info: '',
        t3_info: ''
      };

      ['t1', 't2', 't3'].forEach((tKey, tIdx) => {
        const cast = result[tKey as keyof Omit<MatchingResult, 'pair_no' | 'user_a' | 'user_b' | 't1_info' | 't2_info' | 't3_info'>];
        const info: string[] = [];
        
        if (u_a.casts.includes(cast as string)) info.push('A希望');
        if (u_b && u_b.casts.includes(cast as string)) info.push('B希望');
        
        result[`${tKey}_info` as 't1_info' | 't2_info' | 't3_info'] = 
          info.length ? `(${info.join(', ')})` : '';
      });

      results.push(result);
    });

    return results;
  }
}


================================================================================
 FILE: globals.css
================================================================================

@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}


================================================================================
 FILE: infrastructures\googleSheets\sheet_service.ts
================================================================================

// F:\DEVELOPFOLDER\dev-core\app\infrastructures\googleSheets\sheet_service.ts

export class SheetService {
  /**
   * URLからSpreadsheetIDを抽出する
   * 例: https://docs.google.com/spreadsheets/d/12345/edit -> 12345
   */
  private extractId(url: string): string {
    const match = url.match(/\/d\/([^/]+)/);
    return match ? match[1] : url;
  }

  /**
   * 指定したURLと範囲からデータを取得する
   * /api/sheets に作成するAPIエンドポイントを経由して取得
   */
  async fetchSheetData(url: string, range: string): Promise<any[]> {
    const spreadsheetId = this.extractId(url);
    
    // 自作のAPIルート (/api/sheets/route.ts) を叩く
    const response = await fetch('/api/sheets', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ spreadsheetId, range }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`APIエラー: ${response.status} - ${errorText}`);
    }

    const data = await response.json();
    
    if (data.error) {
      throw new Error(data.error);
    }
    
    return data.values || [];
  }

  // 下記は互換性のために残す（中身はfetchSheetDataを使う）
  async fetchUserData(url: string): Promise<any[]> {
    return this.fetchSheetData(url, 'A2:G100'); // 範囲はシート構造に合わせる
  }

  async fetchCastData(url: string): Promise<any[]> {
    return this.fetchSheetData(url, 'A2:B50'); // 範囲はシート構造に合わせる
  }
}

================================================================================
 FILE: layout.tsx
================================================================================

import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}


================================================================================
 FILE: page.tsx
================================================================================

// FILE: app/page.tsx (全量書き換え)
'use client';

import React from 'react';
import { AppProvider } from './stores/AppContext';
import { AppContainer } from './pages/AppContainer';

export default function HomePage() {
  return (
    <AppProvider>
      <AppContainer />
    </AppProvider>
  );
}

================================================================================
 FILE: pages\AppContainer.css
================================================================================

/* app/pages/AppContainer.css - test.html のカラーリングを適用 */

.app-container * {
  box-sizing: border-box;
}

/* test.html の .app-bg と同じ多方向グラデーション */
.app-container {
  display: flex;
  height: 100vh;
  width: 100vw;
  position: relative;
  font-family: "gg sans", "Whitney", "Helvetica Neue", Helvetica, Arial, sans-serif;
  color: #dbdee1;
  background:
    radial-gradient(circle at 0% 0%, rgba(26, 10, 26, 1) 0%, transparent 50%),
    radial-gradient(circle at 100% 100%, rgba(5, 18, 27, 1) 0%, transparent 50%),
    #0d0b1e;
}

.sidebar {
  width: 240px;
  background: rgba(0, 0, 0, 0.2);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  display: flex;
  flex-direction: column;
  padding: 12px 8px;
  flex-shrink: 0;
  border-right: 1px solid rgba(255, 255, 255, 0.1);
}

.sidebar-button {
  background: transparent;
  border: none;
  color: rgba(255, 255, 255, 0.4);
  padding: 10px 12px;
  text-align: left;
  font-size: 16px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  border-radius: 4px;
  margin: 2px 0;
  display: block;
  width: 100%;
}

.sidebar-button:hover {
  background: rgba(255, 255, 255, 0.06);
  color: #dbdee1;
}

.sidebar-button.active {
  background: rgba(255, 255, 255, 0.08);
  color: #ffffff;
}

.main-content {
  flex: 1;
  overflow-y: auto;
  background: transparent;
}

.main-content::-webkit-scrollbar {
  width: 8px;
}
.main-content::-webkit-scrollbar-track {
  background: transparent;
}
.main-content::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.15);
  border-radius: 4px;
}


================================================================================
 FILE: pages\AppContainer.tsx
================================================================================

// F:\DEVELOPFOLDER\dev-core\app\pages\AppContainer.tsx

import React from 'react';
import { ImportPage } from './ImportPage';
import { DBViewPage } from './DBViewPage';
import { CastManagementPage } from './CastManagementPage';
import { LotteryPage } from './LotteryPage';
import { MatchingPage } from './MatchingPage';
import { useAppContext, type PageType } from '../stores/AppContext';
import { SheetService } from '../infrastructures/googleSheets/sheet_service';
import './AppContainer.css';

export const AppContainer: React.FC = () => {
  const { activePage, setActivePage, repository, currentWinners } = useAppContext();
  const sheetService = new SheetService();

  const renderPage = () => {
    switch (activePage) {
      case 'import':
        return <ImportPage onSuccess={loadData} />;
      case 'db':
        return <DBViewPage />;
      case 'cast':
        return <CastManagementPage repository={repository} />;
      case 'lottery':
        return <LotteryPage />;
      case 'matching':
        return (
          <MatchingPage
            winners={currentWinners}
            allUserData={repository.getAllApplyUsers()}
            repository={repository}
          />
        );
      default:
        return <ImportPage onSuccess={loadData} />;
    }
  };

  const loadData = async (userUrl: string, castUrl: string) => {
    try {
      const userValues = await sheetService.fetchSheetData(userUrl, 'A2:G100');
      const importedUsers = userValues.map(row => ({
        timestamp: row[0] || '',
        name: row[1] || '',
        x_id: row[2] || '',
        first_flag: row[3] || '',
        casts: row[4] ? row[4].split(',').map((s: string) => s.trim()) : [],
        note: row[5] || '',
        is_pair_ticket: row[6] === '1',
        raw_extra: []
      }));

      const castValues = await sheetService.fetchSheetData(castUrl, 'A2:B50');
      const importedCasts = castValues.map(row => ({
        name: row[0] || '',
        is_present: row[1] !== '1'
      }));

      repository.saveApplyUsers(importedUsers);
      repository.saveCasts(importedCasts);
      setActivePage('db');
    } catch (error) {
      console.error('Data Load Error:', error);
      alert('データの読み取りに失敗したよ。\n・URLが正しいか\n・スプレッドシートがサービスアカウントに共有されているか\nを確認して。');
    }
  };

  const sidebarButtons: { text: string; page: PageType }[] = [
    { text: 'データ読取', page: 'import' },
    { text: 'DBデータ確認', page: 'db' },
    { text: 'キャスト管理', page: 'cast' },
    { text: '抽選', page: 'lottery' },
    { text: 'マッチング', page: 'matching' },
  ];

  return (
    <div className="app-container">
      <div className="sidebar">
        {sidebarButtons.map((button, index) => (
          <button
            key={index}
            className={`sidebar-button ${activePage === button.page ? 'active' : ''}`}
            onClick={() => setActivePage(button.page)}
          >
            {button.text}
          </button>
        ))}
      </div>

      <div className="main-content">
        {renderPage()}
      </div>
    </div>
  );
};


================================================================================
 FILE: pages\CastManagementPage.tsx
================================================================================

import React, { useState, useEffect } from 'react';
import { CastBean, Repository } from '../stores/AppContext';
import { DiscordColors } from '../common/types/discord-colors';

export const CastManagementPage: React.FC<{ repository: Repository }> = ({ repository }) => {
  const [casts, setCasts] = useState<CastBean[]>([]);

  useEffect(() => {
    setCasts(repository.getAllCasts());
  }, [repository]);

  const toggle = (cast: CastBean) => {
    repository.updateCastPresence(cast.name, !cast.is_present);
    setCasts([...repository.getAllCasts()]);
  };

  const gridStyle: React.CSSProperties = {
    display: 'grid',
    gridTemplateColumns: 'repeat(auto-fill, minmax(200px, 1fr))',
    gap: '12px',
  };

  const getCastCardStyle = (cast: CastBean): React.CSSProperties => ({
    backgroundColor: cast.is_present ? DiscordColors.itemActive : DiscordColors.bgDark,
    border: `1px solid ${cast.is_present ? DiscordColors.accentGreen : DiscordColors.border}`,
    padding: '14px 16px',
    borderRadius: '6px',
    cursor: 'pointer',
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center',
    transition: 'all 0.15s ease',
  });

  const getCastNameStyle = (cast: CastBean): React.CSSProperties => ({
    color: cast.is_present ? DiscordColors.textNormal : DiscordColors.textMuted,
    fontWeight: 500,
    fontSize: '14px',
  });

  const getCastStatusStyle = (cast: CastBean): React.CSSProperties => ({
    fontSize: '12px',
    color: cast.is_present ? DiscordColors.accentGreen : DiscordColors.accentRed,
    fontWeight: 600,
  });

  return (
    <div style={{ padding: '24px 16px' }}>
      <div style={{ marginBottom: '20px', paddingBottom: '16px', borderBottom: `1px solid ${DiscordColors.border}` }}>
        <h1 style={{ margin: 0, fontSize: '20px', fontWeight: 600, color: DiscordColors.textHeader, marginBottom: '4px' }}>
          キャスト出席管理
        </h1>
        <p style={{ margin: 0, fontSize: '14px', color: DiscordColors.textMuted }}>
          キャストをクリックして出席・欠席を切り替えてください
        </p>
      </div>

      <div style={gridStyle}>
        {casts.map((cast, i) => (
          <div
            key={i}
            onClick={() => toggle(cast)}
            style={getCastCardStyle(cast)}
            onMouseEnter={(e) => {
              e.currentTarget.style.backgroundColor = cast.is_present ? DiscordColors.bgHover : DiscordColors.itemHover;
            }}
            onMouseLeave={(e) => {
              e.currentTarget.style.backgroundColor = cast.is_present ? DiscordColors.itemActive : DiscordColors.bgDark;
            }}
          >
            <span style={getCastNameStyle(cast)}>{cast.name}</span>
            <span style={getCastStatusStyle(cast)}>{cast.is_present ? '● 出席' : '○ 欠席'}</span>
          </div>
        ))}
      </div>

      {casts.length === 0 && (
        <div
          style={{
            textAlign: 'center',
            padding: '60px 20px',
            color: DiscordColors.textMuted,
            fontSize: '14px',
          }}
        >
          キャストデータがありません。スプレッドシートを読み込んでください。
        </div>
      )}
    </div>
  );
};


================================================================================
 FILE: pages\DBViewPage.tsx
================================================================================

import React from 'react';
import { useAppContext } from '../stores/AppContext';
import { DiscordColors } from '../common/types/discord-colors';

export const DBViewPage: React.FC = () => {
  const { repository, setActivePage } = useAppContext();
  const userData = repository.getAllApplyUsers();

  const tableHeaderStyle: React.CSSProperties = {
    textAlign: 'left',
    padding: '12px 16px',
    fontSize: '12px',
    color: DiscordColors.textMuted,
    textTransform: 'uppercase',
    fontWeight: 600,
    borderBottom: `1px solid ${DiscordColors.border}`,
    backgroundColor: DiscordColors.bgSidebar,
  };

  const cellStyle: React.CSSProperties = {
    padding: '12px 16px',
    fontSize: '14px',
    color: DiscordColors.textNormal,
    borderBottom: `1px solid ${DiscordColors.border}`,
  };

  return (
    <div style={{ padding: '24px 16px' }}>
      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '20px' }}>
        <h1 style={{ color: DiscordColors.textHeader, fontSize: '20px', margin: 0 }}>名簿データベース</h1>
        <button
          onClick={() => setActivePage('lottery')}
          style={{
            backgroundColor: DiscordColors.accentYellow,
            color: '#000',
            border: 'none',
            padding: '8px 16px',
            borderRadius: '4px',
            fontWeight: 600,
            cursor: 'pointer',
            fontSize: '14px',
          }}
        >
          抽選設定へ進む
        </button>
      </div>

      <div style={{ backgroundColor: DiscordColors.bgDark, borderRadius: '8px', overflow: 'hidden', border: `1px solid ${DiscordColors.border}` }}>
        <table style={{ width: '100%', borderCollapse: 'collapse' }}>
          <thead>
            <tr>
              <th style={tableHeaderStyle}>名前</th>
              <th style={tableHeaderStyle}>X ID</th>
              <th style={tableHeaderStyle}>希望1</th>
              <th style={tableHeaderStyle}>希望2</th>
              <th style={tableHeaderStyle}>備考</th>
            </tr>
          </thead>
          <tbody>
            {userData.map((user, i) => (
              <tr key={i} style={{ backgroundColor: i % 2 === 0 ? 'transparent' : DiscordColors.bgAlt }}>
                <td style={cellStyle}>{user.name}</td>
                <td style={{ ...cellStyle, color: DiscordColors.textLink }}>@{user.x_id}</td>
                <td style={cellStyle}>{user.casts[0] ?? '—'}</td>
                <td style={cellStyle}>{user.casts[1] ?? '—'}</td>
                <td style={{ ...cellStyle, color: DiscordColors.textMuted, fontSize: '12px' }}>{user.note}</td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  );
};


================================================================================
 FILE: pages\ImportPage.tsx
================================================================================

import React, { useState } from 'react';
import { DiscordColors } from '../common/types/discord-colors';

interface ImportPageProps {
  onSuccess: (userUrl: string, castUrl: string) => void;
}

export const ImportPage: React.FC<ImportPageProps> = ({ onSuccess }) => {
  const [userUrl, setUserUrl] = useState('https://docs.google.com/spreadsheets/d/1-1bz7LuxCPADoWCEj24TL6QmOMPzvhmUeUtCiZLp2jo/edit');
  const [castUrl, setCastUrl] = useState('https://docs.google.com/spreadsheets/d/1rc_QdWi805TaZ_2e8uV_odpc4DRQNVnC5ET6W63LzPw/edit');

  const cardStyle: React.CSSProperties = {
    backgroundColor: DiscordColors.bgDark,
    borderRadius: '8px',
    padding: '24px 32px',
    maxWidth: '600px',
    margin: '24px auto',
    border: `1px solid ${DiscordColors.border}`,
  };

  const labelStyle: React.CSSProperties = {
    color: DiscordColors.textMuted,
    fontSize: '12px',
    fontWeight: 700,
    textTransform: 'uppercase',
    marginBottom: '8px',
    display: 'block',
  };

  const inputStyle: React.CSSProperties = {
    width: '100%',
    backgroundColor: DiscordColors.bgDark,
    border: `1px solid ${DiscordColors.border}`,
    padding: '10px 12px',
    borderRadius: '4px',
    color: DiscordColors.textNormal,
    fontSize: '16px',
    marginBottom: '20px',
    outline: 'none',
  };

  const buttonStyle: React.CSSProperties = {
    backgroundColor: DiscordColors.accentBlue,
    color: '#fff',
    border: 'none',
    padding: '12px 24px',
    borderRadius: '4px',
    fontSize: '14px',
    fontWeight: 600,
    cursor: 'pointer',
    width: '100%',
    transition: 'background-color 0.2s',
  };

  return (
    <div style={{ padding: '24px 16px' }}>
      <div style={cardStyle}>
        <h2 style={{ color: DiscordColors.textHeader, fontSize: '20px', marginBottom: '4px' }}>
          外部連携設定
        </h2>
        <p style={{ color: DiscordColors.textMuted, fontSize: '14px', marginBottom: '24px' }}>
          スプレッドシートのURLを同期します。
        </p>

        <label style={labelStyle}>応募者名簿 URL</label>
        <input style={inputStyle} value={userUrl} onChange={(e) => setUserUrl(e.target.value)} />

        <label style={labelStyle}>キャストリスト URL</label>
        <input style={inputStyle} value={castUrl} onChange={(e) => setCastUrl(e.target.value)} />

        <button
          style={buttonStyle}
          onClick={() => onSuccess(userUrl, castUrl)}
          onMouseOver={(e) => { e.currentTarget.style.backgroundColor = '#4752c4'; }}
          onMouseOut={(e) => { e.currentTarget.style.backgroundColor = DiscordColors.accentBlue; }}
        >
          保存して同期を開始
        </button>
      </div>
    </div>
  );
};


================================================================================
 FILE: pages\LotteryPage.tsx
================================================================================

import React, { useState } from 'react';
import { useAppContext } from '../stores/AppContext';
import { DiscordColors } from '../common/types/discord-colors';

export const LotteryPage: React.FC = () => {
  const { setActivePage, repository, setCurrentWinners } = useAppContext();
  const [count, setCount] = useState(15);

  const run = () => {
    const all = repository.getAllApplyUsers();
    const shuffled = [...all].sort(() => 0.5 - Math.random());
    setCurrentWinners(shuffled.slice(0, count));
    setActivePage('matching');
  };

  return (
    <div style={{ display: 'flex', minHeight: '100%', alignItems: 'center', justifyContent: 'center', padding: '24px' }}>
      <div
        style={{
          backgroundColor: DiscordColors.bgDark,
          padding: '32px 40px',
          borderRadius: '8px',
          width: '100%',
          maxWidth: '400px',
          textAlign: 'center',
          border: `1px solid ${DiscordColors.border}`,
        }}
      >
        <h1 style={{ color: DiscordColors.textHeader, fontSize: '20px', marginBottom: '24px' }}>
          抽選の実行
        </h1>

        <div style={{ marginBottom: '28px' }}>
          <label style={{ color: DiscordColors.textMuted, display: 'block', marginBottom: '10px', fontSize: '12px', fontWeight: 600, textTransform: 'uppercase' }}>
            当選人数
          </label>
          <input
            type="number"
            value={count}
            onChange={(e) => setCount(Number(e.target.value))}
            style={{
              width: '80px',
              backgroundColor: DiscordColors.bgSidebar,
              border: `1px solid ${DiscordColors.border}`,
              padding: '12px',
              borderRadius: '4px',
              color: DiscordColors.textNormal,
              fontSize: '20px',
              textAlign: 'center',
              outline: 'none',
            }}
          />
        </div>

        <button
          onClick={run}
          style={{
            width: '100%',
            backgroundColor: DiscordColors.accentBlue,
            color: '#fff',
            border: 'none',
            padding: '14px',
            borderRadius: '4px',
            fontWeight: 600,
            fontSize: '16px',
            cursor: 'pointer',
          }}
        >
          抽選を開始する
        </button>
      </div>
    </div>
  );
};


================================================================================
 FILE: pages\MatchingPage.tsx
================================================================================

import React, { useState } from 'react';
import { UserBean, useAppContext } from '../stores/AppContext';
import { MatchingService } from '../features/matching/logics/matching_service';
import { DiscordColors } from '../common/types/discord-colors';

interface MatchingResult {
  pair_no: string;
  user_a: UserBean;
  user_b: UserBean;
  t1: string;
  t1_info: string;
  t2: string;
  t2_info: string;
  t3: string;
  t3_info: string;
}

export const MatchingPage: React.FC<{
  winners: UserBean[];
  allUserData: UserBean[];
  repository: ReturnType<typeof useAppContext>['repository'];
}> = ({ winners: currentWinners, repository }) => {
  const [results, setResults] = useState<MatchingResult[]>([]);
  const [showResults, setShowResults] = useState(false);

  const containerStyle: React.CSSProperties = {
    padding: '24px 16px',
    minHeight: '100%',
    color: DiscordColors.textNormal,
  };

  const tableWrapperStyle: React.CSSProperties = {
    backgroundColor: DiscordColors.bgDark,
    borderRadius: '8px',
    overflow: 'hidden',
    border: `1px solid ${DiscordColors.border}`,
    marginBottom: '24px',
  };

  const headerCellStyle: React.CSSProperties = {
    backgroundColor: DiscordColors.bgSidebar,
    color: DiscordColors.textMuted,
    padding: '12px 16px',
    fontSize: '12px',
    fontWeight: 600,
    textTransform: 'uppercase',
    borderBottom: `1px solid ${DiscordColors.border}`,
    textAlign: 'left',
  };

  const cellStyle: React.CSSProperties = {
    padding: '12px 16px',
    borderBottom: `1px solid ${DiscordColors.border}`,
    fontSize: '14px',
  };

  const startMatching = () => {
    if (currentWinners.length === 0) {
      alert('当選者が選択されていません。');
      return;
    }
    const service = new MatchingService(currentWinners, repository);
    const matchingResults = service.runMatching();
    setResults(matchingResults as MatchingResult[]);
    setShowResults(true);
  };

  if (showResults) {
    return (
      <div style={containerStyle}>
        <div style={{ marginBottom: '24px' }}>
          <h1 style={{ color: DiscordColors.textHeader, margin: 0, fontSize: '20px' }}>マッチング完了</h1>
          <p style={{ color: DiscordColors.textMuted, margin: '4px 0', fontSize: '14px' }}>生成されたローテーション案です</p>
        </div>
        <div style={tableWrapperStyle}>
          <table style={{ width: '100%', borderCollapse: 'collapse' }}>
            <thead>
              <tr>
                <th style={headerCellStyle}>ペア</th>
                <th style={headerCellStyle}>ユーザーA</th>
                <th style={headerCellStyle}>ユーザーB</th>
                <th style={headerCellStyle}>T1</th>
                <th style={headerCellStyle}>T2</th>
                <th style={headerCellStyle}>T3</th>
              </tr>
            </thead>
            <tbody>
              {results.map((r, i) => (
                <tr key={i} style={{ backgroundColor: i % 2 === 0 ? 'transparent' : DiscordColors.bgAlt }}>
                  <td style={{ ...cellStyle, color: DiscordColors.accentBlue, fontWeight: 600 }}>{r.pair_no}</td>
                  <td style={cellStyle}>{r.user_a.name}</td>
                  <td style={cellStyle}>{r.user_b.name}</td>
                  <td style={cellStyle}>
                    <div style={{ color: DiscordColors.accentYellow, fontWeight: 600 }}>{r.t1}</div>
                    <div style={{ color: DiscordColors.textMuted, fontSize: '12px' }}>{r.t1_info}</div>
                  </td>
                  <td style={cellStyle}>
                    <div style={{ color: DiscordColors.accentYellow, fontWeight: 600 }}>{r.t2}</div>
                    <div style={{ color: DiscordColors.textMuted, fontSize: '12px' }}>{r.t2_info}</div>
                  </td>
                  <td style={cellStyle}>
                    <div style={{ color: DiscordColors.accentYellow, fontWeight: 600 }}>{r.t3}</div>
                    <div style={{ color: DiscordColors.textMuted, fontSize: '12px' }}>{r.t3_info}</div>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
          <div style={{ padding: '16px' }}>
            <button
              type="button"
              style={{
                background: 'none',
                border: 'none',
                color: DiscordColors.textLink,
                cursor: 'pointer',
                fontSize: '14px',
              }}
              onClick={() => setShowResults(false)}
            >
              ← 設定に戻る
            </button>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div style={containerStyle}>
      <div style={{ marginBottom: '24px' }}>
        <h1 style={{ color: DiscordColors.textHeader, margin: 0, fontSize: '20px' }}>マッチング構成確認</h1>
        <p style={{ color: DiscordColors.textMuted, margin: '4px 0', fontSize: '14px' }}>
          当選者リストに基づきペアを自動生成します
        </p>
      </div>
      <div style={tableWrapperStyle}>
        <table style={{ width: '100%', borderCollapse: 'collapse' }}>
          <thead>
            <tr>
              <th style={headerCellStyle}>卓</th>
              <th style={headerCellStyle}>ユーザー名</th>
              <th style={headerCellStyle}>ID</th>
              <th style={headerCellStyle}>希望キャスト</th>
            </tr>
          </thead>
          <tbody>
            {Array.from({ length: 15 }, (_, i) => {
              const winner = currentWinners[i];
              return (
                <tr key={i} style={{ backgroundColor: i % 2 === 0 ? 'transparent' : DiscordColors.bgAlt }}>
                  <td style={{ ...cellStyle, color: DiscordColors.accentBlue, fontWeight: 600 }}>卓 {i + 1}</td>
                  <td style={cellStyle}>{winner ? winner.name : '—'}</td>
                  <td style={{ ...cellStyle, color: DiscordColors.textMuted }}>{winner ? `@${winner.x_id}` : ''}</td>
                  <td style={cellStyle}>{winner ? winner.casts.join(', ') : ''}</td>
                </tr>
              );
            })}
          </tbody>
        </table>
      </div>
      <div
        style={{
          marginTop: '24px',
          display: 'flex',
          justifyContent: 'center',
        }}
      >
        <button
          type="button"
          style={{
            backgroundColor: DiscordColors.buttonSuccess,
            color: '#fff',
            border: 'none',
            padding: '12px 32px',
            borderRadius: '4px',
            fontSize: '16px',
            fontWeight: 600,
            cursor: 'pointer',
          }}
          onClick={startMatching}
        >
          マッチング開始
        </button>
      </div>
    </div>
  );
};


================================================================================
 FILE: stores\AppContext.tsx
================================================================================

import React, { createContext, useContext, useState, ReactNode } from 'react';

export interface UserBean {
  timestamp: string;
  name: string;
  x_id: string;
  first_flag: string;
  casts: string[];
  note: string;
  is_pair_ticket: boolean;
  raw_extra: any[];
}

export interface CastBean {
  name: string;
  is_present: boolean;
}

export type PageType = 'import' | 'db' | 'cast' | 'lottery' | 'matching';

export class Repository {
  private users: UserBean[] = [];
  private casts: CastBean[] = [];

  saveApplyUsers(users: UserBean[]) { this.users = users; }
  getAllApplyUsers(): UserBean[] { return this.users; }
  saveCasts(casts: CastBean[]) { this.casts = casts; }
  getAllCasts(): CastBean[] { return this.casts; }
  updateCastPresence(name: string, isPresent: boolean) {
    const cast = this.casts.find((c) => c.name === name);
    if (cast) cast.is_present = isPresent;
  }
}

interface AppContextType {
  activePage: PageType;
  setActivePage: (page: PageType) => void;
  repository: Repository;
  currentWinners: UserBean[];
  setCurrentWinners: (winners: UserBean[]) => void;
}

const AppContext = createContext<AppContextType | undefined>(undefined);
const repositoryInstance = new Repository();

export const AppProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [activePage, setActivePage] = useState<PageType>('import');
  const [currentWinners, setCurrentWinners] = useState<UserBean[]>([]);

  return (
    <AppContext.Provider value={{
      activePage, setActivePage, repository: repositoryInstance,
      currentWinners, setCurrentWinners
    }}>
      {children}
    </AppContext.Provider>
  );
};

export const useAppContext = () => {
  const context = useContext(AppContext);
  if (!context) throw new Error('useAppContext must be used within an AppProvider');
  return context;
};
